<h1>Small Soft pack</h1>
<p>Made for God Glory.<br />
Hail Supreame God one in Great Trinity.<br />
Prise Saint Maria, mother of God.  </p>
<p>A pack of my little unix programs.<br />
I do not mention dependencies like C compiler and posix system.<br />
None means you have the basic set.  </p>
<p>I wrote this code for my personal use.<br />
Shell hacks for life. ;-)  </p>
<p>You can either read this file as plain text<br />
( and still understand 100% of what is this read me about ).<br />
Or you can use your webbrowser to read it:  </p>
<blockquote>
<p><code>firefox readme.html</code>  </p>
</blockquote>
<h2>INSTALLATION:</h2>
<h3>1) downloading</h3>
<p>Before we install, we need to suck this up:  </p>
<blockquote>
<p><code>git clone 'https://github.com/ignotaC/smallsoft'</code>  </p>
</blockquote>
<h3>2) compilation</h3>
<p>Run make in makefile:  </p>
<blockquote>
<p><code>make</code>  </p>
</blockquote>
<p>Make before compilation will upload<br />
required submodules - ignotalib.<br />
Compiled programs will go to the newly created<br />
bin directory inside smallsoft.  </p>
<h3>3) installation ( binary managment )</h3>
<p>You do it by your self, You might no want to<br />
use some of the software this pack provides.<br />
Simply copy what ever you want to one of the<br />
preffered PATH directory which you can see<br />
after running env command. Since I add<br />
~/bin to my PATH with .xsession.<br />
I simply take all by doing:  </p>
<blockquote>
<p><code>cp bin/* ~/bin</code>  </p>
</blockquote>
<h3>4) clean up</h3>
<p>This simply removes stuff make created<br />
inside the directory of your makefile.  </p>
<blockquote>
<p>'make clear'</p>
</blockquote>
<h2>Program list:</h2>
<ol>
<li>
<p><strong>coin</strong>  </p>
<blockquote></blockquote>
<p>Program lets you find an answer to a 0/1 problem.<br />
Program does not take any arguments.<br />
Dependencies: none
Example of using it:  </p>
<blockquote>
<p><code>coin</code> </p>
</blockquote>
</li>
<li>
<p><strong>getproxies</strong> <code>[ pattern ]</code>  </p>
<blockquote></blockquote>
<p>Program filters few webpages to suck up proxies,<br />
also checks  if they work properly. Data is saved<br />
to a file named  "proxylist" inside working directory.<br />
Slow proxies that do not respond quick enought and<br />
resoults that repeated are removed.<br />
The file will contain each uploaded proxy data per line.<br />
Lines will be formated like this:  </p>
<blockquote>
<p><code>&lt;IP&gt; &lt;port&gt; &lt;country&gt; &lt;anonimyty type&gt; &lt;http or https support&gt;</code></p>
</blockquote>
<p>Program takes arguments. If line contains any<br />
of the passed words, the line will be removed.<br />
The search is case insensetive. So passing<br />
'http' or 'HTTP' will remove any line that contains 'http'<br />
Dependencies: <strong>wget</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>getproxies china</code>  </p>
</blockquote>
<p>This will create the 'proxylist' file with resoults but<br />
without lines containing word 'china'. Upper or<br />
lower cases won't matter. So line contaning 'chINA'<br />
will also be removed. China proxies most times are garbage,<br />
so you want them removed. Other type of use would be<br />
getting rid 'transparet' proxies.  Altho you should never<br />
trust anonimity type of proxy. Some servers will pass<br />
your IP if for example user-ganet will not fit their<br />
expectations.  </p>
</li>
<li>
<p><strong>novena</strong></p>
<blockquote></blockquote>
<p>Program will save file in home directory and track what<br />
current day of novena we have. Program does not take any<br />
arguments. It will either tell you the current novena<br />
day (novena lasts 9 days always). Or it will ask you<br />
for new novena name. Program creates in user home<br />
directory taken from enviroment list .novena file. Where<br />
it keeps data. If 9 days pass program will inform you<br />
the novena has ended.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>novena</code>  </p>
</blockquote>
</li>
<li>
<p><strong>workout</strong></p>
<blockquote></blockquote>
<p>Program generates workout entries for each day. Entries<br />
are stored inside .workout file in enviroment home<br />
directory. Program does not take any arguments.<br />
The file is generated automatically when program is run.<br />
For current day it shall output:  </p>
<ul>
<li>exercise type,  </li>
<li>weight level - how much load you will lift   </li>
<li>series count per exercise  </li>
<li>Hardness - how many times repeate per one series  </li>
<li>Count of exercise type  </li>
</ul>
<p>Dependencies: none<br />
Example of using it::  </p>
<blockquote>
<p><code>workout</code>  </p>
</blockquote>
</li>
<li>
<p><strong>logtime</strong></p>
<blockquote></blockquote>
<p>Program logs time per each line  that appears at stdin.<br />
Output format:  </p>
<blockquote>
<p><code>&lt;seconds&gt;.&lt;miliseconds&gt;&lt;space&gt;&lt;passed line&gt;</code>  </p>
</blockquote>
<p>Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>program | logtime</code>  </p>
</blockquote>
<p>You should rememer that | is buffered and will not<br />
pass everything immediatly always. So the real time<br />
can be different than the loged one.  </p>
</li>
<li>
<p><strong>recev</strong></p>
<blockquote></blockquote>
<p>Program creates a record of pressed mouse buttons,<br />
keyboard keys and mouse moves. Program at start<br />
will ask you are you ready. After that you will<br />
need to decide what key will start and stop recording.<br />
You can chose only single keys. Combinations do not<br />
work. You need to type the key so for example<br />
it could be 'F8' or h. After the key is picked,<br />
you must provide a filenmae, where the event data<br />
gets recorded. File will be placed in working<br />
directory. Events that do not matter and repeated<br />
mousemoves are removed to shrint at least a bit the<br />
file where events get saved.  Since it can grow quite<br />
big. This program does not take any arguments.<br />
Aditionaly <strong>xenv</strong> program can help with finding key name.<br />
Dependencies:  <strong>xmodmap</strong>, <strong>xinput</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>recev</code></p>
</blockquote>
</li>
<li>
<p><strong>playev</strong> <code>[ file name ] [ number ] [ seconds ] [ seconds ]</code></p>
<blockquote></blockquote>
<p>Program playes events from file created by recev program.<br />
Program needs four arguments:  </p>
<ul>
<li>file name - it is the file created by recev.  </li>
<li>number of times event gets repeated, 0 causes<br />
to be repeated infinite times.  </li>
<li>seconds to wait before playing events loop  </li>
<li>seconds to wait between instance of recorded events.  </li>
</ul>
<p>Dependencies: <strong>xmodmap</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>playev recorded_file 100 10 1</code></p>
</blockquote>
<p>This will play event recorded in passed file name<br />
100 times. Program will start playing events after<br />
10 seconds and each time all events in recorded<br />
file are played, it will wait 1 second and replay the<br />
events. Untill reached the expected repeated number.  </p>
</li>
<li>
<p><strong>gethostipv</strong> <code>[ -46 ] [ domain ]</code></p>
<blockquote></blockquote>
<p>Program uses system resolver tools to get the ip<br />
of the domain. Program expects at least the domain name<br />
argument. Order of arguments does not matter. But at<br />
maximum there can be only two arguments. So the options<br />
must not be separated like this: <code>-4 -6</code><br />
Instead it should look like this: <code>-46</code><br />
So we have four possibilities of passing options:  </p>
<blockquote>
<p><code>-4 or -6 or -46 or -64</code>  </p>
</blockquote>
<p>Options:  </p>
<p><code>-4</code><br />
Look only for IPv4 address  </p>
<p><code>-6</code><br />
Look only for  IPv6 address  </p>
<p>Address shall only be outputted to stdout if it is possible<br />
to connect to it. Mapping ipv4 to ipv6 is not checked.<br />
So if the host has ipv6 and ipv4  but we can't connect to ipv6<br />
and instead we need to use ipv4. When flag <code>-46</code> was passed,<br />
ipv4 will be shown.  But if we passed option<code>-6</code>.<br />
Nothing shall be outputted. If host has more addresses,<br />
and we can connect to each of them.<br />
All will be outputted. Passsing <code>-46</code> means - check first for<br />
ipv4, than for ipv6. If <code>-64</code> vice versa.<br />
If we pass domain name without options. Both ipv4 and ipv6<br />
are checked, but the order is undefined.
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>gethostipv -64 www.dom.com</code>  </p>
</blockquote>
<p>In which we ask to output first ipv6 possible addresses<br />
that we could connect to and than ipv4. For the<br />
www.dom.com domain.  </p>
</li>
<li>
<p><strong>repeatstr</strong> <code>[ number ] [ pattern ]</code></p>
<blockquote></blockquote>
<p>Program repeats passed phrase specified number of times.<br />
There are always expected two arguments.<br />
First one is number of times string will be repeated.<br />
Second is the string it self that program will repeat.<br />
Supported character sequances:  </p>
<ul>
<li><code>\a</code> = bell  </li>
<li><code>\b</code> = backspace  </li>
<li><code>\f</code> = form feed  </li>
<li><code>\r</code> = carrige return  </li>
<li><code>\n</code> = new line  </li>
<li><code>\i</code> = This is very special, you can pass it in pattern<br />
only one time, it will increment from zero to  number - 1</li>
<li><code>\t</code> = tab  </li>
<li><code>\v</code> = vertical tab  </li>
<li><code>\\</code> = backslash  </li>
</ul>
<p>Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>repeatstr 100 'this gets repeated 100 times'</code><br />
<code></code><br />
<code>repeatestr 3 'Increment number: \i'</code>  </p>
</blockquote>
<p>Last example output wil look like this:  </p>
<blockquote>
<p><code>Increment number: 0</code><br />
<code>Increment number: 1</code><br />
<code>Increment number: 2</code>  </p>
</blockquote>
</li>
<li>
<p><strong>lext</strong> <code>[ -clp ] [ pattern1 ] [ pattern2 ]</code>  </p>
<blockquote></blockquote>
<p>Program extracts strings form stdin. Don't pass any<br />
arguments to it and help will be outputed.<br />
For proper use, this program expects arguments.<br />
There are three options to chose from. 
Options:  </p>
<p><code>-c _string1_ _string2_</code><br />
Output data between <em>string1</em> and <em>string2</em><br />
Which both are on same line.  </p>
<p><code>-l</code><br />
Loop last command.  </p>
<p><code>-p _string_</code><br />
Pass data untill <em>string</em> is located.  </p>
<p>After EOF is met - program ends.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>cat datafile | strext -p 'dev' -c 'name="' '"' -l</code>  </p>
</blockquote>
<p>This will read datafile from stdin untill 'dev' is met.<br />
After that program will look for data which lies between<br />
'name="' and '"' where both strings will be on the same line.<br />
Finally loop the last command, look for dara between<br />
specified strings untill EOF met on stdin.</p>
</li>
<li>
<p><strong>getlimits</strong></p>
<blockquote></blockquote>
<p>Program prints system soft and hard resource consumption.<br />
Basic are:  </p>
<ul>
<li>Maximum core file size  </li>
<li>Maximum CPU time used by each process  </li>
<li>Maximum size of data segment including allocations  </li>
<li>Maximum size of file that can be created  </li>
<li>Maximum number of file descriptors process can open  </li>
<li>Maximum size of process stack  </li>
<li>data segment etc.  </li>
</ul>
<p>Few other system dependant also are printed for linux and<br />
OpenBSD.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>getlimits</code>  </p>
</blockquote>
</li>
<li>
<p><strong>fstrswp</strong> <code>[ pattern1 ] [ pattern2 ]</code></p>
<blockquote></blockquote>
<p>Program will read line and swap any found  string from first argument,<br />
to string in second argument. I use it for source fixing.<br />
Each line gets allocated to heap. After swapping is done<br />
output is sent to stdout anf line gets freed.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>find src -type f -iname '*.c' -exec sh -c \</code><br />
<code>'cat {} | fstrswp '\''malloc.h'\'' '\''stdlib.h'\'\</code><br />
<code>' | tmpfile; mv tmpfile {}' \;</code>  </p>
</blockquote>
<p>This fixes gnuism crap left in code by some<br />
unexpiranced coder. Next run would scan <code>*.h</code>.  </p>
</li>
<li>
<p><strong>parsekdump</strong></p>
<blockquote></blockquote>
<p>This program is openbsd ktrace/kdump output parser.<br />
It shall count system calls and create a summary<br />
of them. It outputs data per PID/TID and on start<br />
summary of all treads and forks.<br />
Summary will contain:</p>
<ul>
<li>System call name</li>
<li>Count of times it was called in all forks and threads</li>
</ul>
<p>Each basic data line for PID/TID will contain:  </p>
<ul>
<li>System call name</li>
<li>Count of times it was called in the process</li>
<li>Procent of system call summary compared to all system calls time</li>
<li>Procent of system call summary to record time</li>
</ul>
<p>Dependencies: openbsd operating system<br />
Example of using it:</p>
<blockquote>
<p><code>ktrace -i program</code><br />
<code>parsekdump</code>  </p>
</blockquote>
<p>ktrace -i option is for tracking forks and threads. I advice to track all<br />
else the output summary might be missleading.  </p>
</li>
<li>
<p><strong>rmvmb</strong></p>
<blockquote></blockquote>
<p>Program removes multibyte characters from input.<br />
Normal one byte characters are redirected to stdout.<br />
Dependencies: none<br />
Example of using it:</p>
<blockquote>
<p><code>echo "$string_with_multibytechars" | rmvmb</code>  </p>
</blockquote>
</li>
<li>
<p><strong>randstr</strong> <code>[ -uld ] [ number ]</code></p>
<blockquote></blockquote>
<p>Program generates random string. It uses pseudorandom generator,<br />
Deterministic C rand().<br />
Without any options any bytes can appear.  So it can even generate nul.<br />
To force more usefull output we have options which we can mix:  </p>
<p><code>-u</code><br />
Print out only upper case output.  </p>
<p><code>-l</code><br />
Print out only lower case output.  </p>
<p><code>-d</code><br />
Print out only digits  </p>
<p>There is no expected order of arguments.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>randstr -uld 50</code>  </p>
</blockquote>
<p>In this example we generate 50 characers where each of them<br />
must be a digit or an upper/lower case alphabet number.<br />
Second example above does the same thing, as we can see,<br />
options can be together and can repeate.  </p>
<blockquote>
<p><code>randstr -d 50 -uuuud -udl</code>  </p>
</blockquote>
</li>
<li>
<p><strong>sndlog_data</strong>  <code>[ -options ] [ socket info ]</code></p>
<blockquote></blockquote>
<p>Program opens unix or internet socket and either sends<br />
data or logs it. It uses TCP protocol, by default picks IPv6 if<br />
both intrefaces ( IPv6 and IPv4 ) are present.<br />
You must always pass an option string and socket information.<br />
Existing options:  </p>
<p><code>-l</code><br />
Log data, everything that is recieved form<br />
connected clients is being redirected on stdout.
Expect FIN at the end of data.<br />
It is an error to pass this option with <code>-s</code> option.  </p>
<p><code>-s</code><br />
Send data, send one line from stdin to every client<br />
that connects, than pass FIN and close connection.<br />
It is an error to pass this option with <code>-l</code> option.  </p>
<p><code>-u</code><br />
Use unix socket for server. Second argument - socket<br />
information, must contain file name unix socket<br />
will use. It is an error to pass this option with <code>-i</code>  </p>
<p><code>-i</code><br />
Use internet socket. Second argument - socket infromation<br />
is port number we want server to use. It is an error<br />
to pass this option together with  <code>-u</code>.</p>
<p>All data send to the socket will be redirected to stdout.<br />
Gentle way of telling server to finish running is sending SIGINT signal to it.<br />
dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>sndlog_data -li 1500</code>  </p>
</blockquote>
<p>This will create internet socket under 1500 port number<br />
and output incoming data to stdout. We could send it data<br />
using <code>nc</code> like this: <code>echo 'weeb' | nc -N 'localhost' '1500'</code>  </p>
<blockquote>
<p><code>sndlog_data -su /tmp/sun_name</code>  </p>
</blockquote>
<p>This will create unix socket file just as socket information says
under '/tmp/sun_name'. Server will send every connection one line<br />
from stdin. We could log data using <code>nc</code> since we like it so much.<br />
just like this: <code>nc -U '/tmp/sun_name'</code>  </p>
</li>
<li>
<p><strong>httpreq_addcrlf</strong></p>
<blockquote></blockquote>
<p>Program adds after new line of each entry CRLF creating<br />
proper http request. After reaching EOF  one more CRLF<br />
is being sent that indicates end of HTTP head.<br />
Empty lines are being ignored.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>cat httpreq | httpreq_addcrlf | nc hate-google-for-life.com 80</code>  </p>
</blockquote>
<p>Where httpreq file would look like this:  </p>
<blockquote>
<p><code>GET /babylon/tower HTTP/1.0</code><br />
<code>Host: gagle.shit</code>  </p>
</blockquote>
</li>
<li>
<p><strong>flinemem</strong> <code>[ phrease1 ] [ phrease2 ] ...</code></p>
<blockquote></blockquote>
<p>This simple program loads from stdin line to memory and searches<br />
if passed arguments exist in line. Line is printed to stdout only<br />
if all strings exist in line. First of all it's much faster then<br />
grep -E ( like 8 times ) since regular expressions are not used,<br />
and also, the egrep ( depracated name )  syntax for like<br />
four arguments and more is nonsens and shit.<br />
Command gets insanely long because someone could not make it simply<br />
"phra1&amp;phra2" or what ever.  This program has none of such issues.<br />
Dependencies: none<br />
Example fo using it:  </p>
<blockquote>
<p><code>cat file | flinemem 'pattern1' 'pattern2' 'pattern3'</code></p>
</blockquote>
</li>
<li>
<p><strong>urlcode</strong> <code>[ -options ] [ data1 ] [ data2 ] [ ... ]</code></p>
<p>Encode or decode urlcode. + &lt;=&gt; space is not supported<br />
It's a browser extension. We have three types of options<br />
and we can choose only one.  </p>
<p><code>-d</code><br />
Decode passed data from stdin and send it to sdtout.<br />
After option arguments no more arguments should appear.  </p>
<p><code>-c</code><br />
Code passed data from stdin and send it to sdtout.<br />
After option arguments no more arguments should appear.  </p>
<p><code>-p</code><br />
Create from passed argumnets http post body. It only<br />
codes urlcode <code>data( 2n + 1 )</code>. So <code>data1</code> gets coded<br />
but <code>data2</code> does not get coded, than <code>`data3</code> is coded<br />
and <code>data4</code> is not coded. And so on..</p>
<p>Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>printf "%s" 'This will get url-encoded' | urlcode -c</code><br />
<code></code><br />
<code>printf "%s"  'Decode this  url-encoded string' | urlcode -d</code><br />
<code></code><br />
<code>postbody=$( urlcode '-p' 'login' '=' 'someone' '&amp;' 'pass' '=' 'secret' \</code><br />
<code>'&amp;' 'hidden_token' '=' '123jhfierhgiuerg12' )</code></p>
</blockquote>
<p>If we plan on further using the postbody it could look like this:  </p>
<blockquote>
<p><code>{ cat httpreq | httpreq_addcrlf; printf "%s" "$postbody"; }  \</code><br />
<code>|  nc -c -X 5 -x localhost:9050 www 443</code>  </p>
</blockquote>
<p>As we can see we pass our http request via tor at the final example.  </p>
</li>
<li>
<p><strong>miodpitny</strong> - program tells you MEAD proportions. </p>
</li>
<li>
<p><strong>irclog</strong> - program to log irc. It's old code. Not too proud of it but I needed to log
             some stuff recently and it worked. So I am adding it here for now.
             Will try to reread it in future for detecting some bugs and other crap.
             How to use: create a file in directory where you will start the irclog program
             The only accepted file name is: log_serv_data
             Else error.
             Contents example:
             Sirc.liberapriviligesqwertycrap.chat 6667
             MNICK dicky 
             MUSER dicky ** :Philip_DICK
             C##channel_1
             C#devchannel_2
             C##channel_3</p>
<pre><code>     Now, S is for server where you pass domain port
     M is for first message you provide at start up, irc proto
     C is for channel you want to join
     There is also I for identication string. I rememebr ages ago it worked but now?
     This will have sooner or later update. But since it works than I am putting it up here.
     Expect broken behavior. It was intended to be able log multiply servers. So next S in 
     config file should merit new network.
     Each channel gets it's own file where stuff gets logged in the directory where you 
     started the program. &lt;networkname&gt;&lt;channame&gt; &lt;- something like this
</code></pre>
<ol>
<li><strong>faddlines</strong> - Program merges files. pritnf on stdout added lines like this:
         line 1 file 1 + space + line 1 file 2\n
         If one file reached eof it gets ignored
         after all files reach EOF - program finishes.
         Where I use it:<pre><code> Let us imagine we have y(t) and x(t);
 We want to plot it in gnuplot;
 We could also have already data files out there.
 Taken from some sensor.

 echo 'for(i=0.1; i &lt; 100; i+=0.1) { i-5 }' | bc &gt; file1
 echo 'for(i=0.1; i &lt; 100; i+=0.1) { i+5 }' | bc &gt; file2
 faddlines file1 file2 &gt; ans;
 ## After that I can plot x,y points with gnuplot to see how it looks.
 gnuplot
 &gt;&gt; p ans

 This program can take multiply files.
</code></pre>
</li>
</ol>
</li>
<li>
<p><strong>cutfile</strong> - program stdouts lines after meeting in line some expression.
              For help run cutfile without any arguments</p>
</li>
<li>
<p><strong>htmlentities</strong> - decode or encode html entities, only some are supported.
                   suported: '&lt;' '&gt;' ' ' '\'' '"' '&amp;' . Rets is treated as errror.
                   honestly I dislike utf8. Let it rot. 
                   How to use -&gt; invoke without any arguments. Still little example:
                   cat urllinksfromhtmlpage | htmlentities -d &gt; proper_url_links</p>
</li>
<li>
<p><strong>httphb_split</strong> - Splits http server answers to http header or the rest ( body )
                   For help simply run it without any arguments.
                   Example: http_serber_answer | httphb_split -h &gt; httpheader_file</p>
</li>
<li><strong>fixedxarg</strong> - Program closly performs same task as xargs, BUT PROPERLY.
                Each new line separates new argument. Empty lines creates ''
                Which normal xarg fails to catch. No options. Example:
                echo  "a\nb\nc\nd\n" | fixedxarg echo</li>
<li><strong>listwords</strong> - </li>
<li><strong>fext</strong></li>
<li><strong>readNMEA</strong></li>
<li><strong>findreserved</strong></li>
<li><strong>version</strong></li>
</ol>