<h1>Small Soft pack</h1>
<p>Made for God Glory.<br />
Hail Supreame God one in Great Trinity.<br />
Prise Saint Maria, mother of God.  </p>
<p>A pack of my little unix programs.
I do not mention dependencies like C compiler and posix system.
None means you have the basic set.</p>
<p>You can either read this file as plain text<br />
( and still understand 100% of what is this read me about ).<br />
Or you can use your webbrowser to read it:  </p>
<blockquote>
<p><code>firefox readme.html</code>  </p>
</blockquote>
<h2>INSTALLATION:</h2>
<h3>1) downloading</h3>
<p>Before we install, we need to suck this up:  </p>
<blockquote>
<p><code>git clone 'https://github.com/ignotaC/smallsoft'</code>  </p>
</blockquote>
<h3>2) compilation</h3>
<p>Run make in makefile:  </p>
<blockquote>
<p><code>make</code>  </p>
</blockquote>
<p>Make before compilation will upload<br />
required submodules - ignotalib.<br />
Compiled programs will go to the newly created<br />
bin directory inside smallsoft.  </p>
<h3>3) installation ( binary managment )</h3>
<p>You do it by your self, You might no want to<br />
use some of the software this pack provides.<br />
Simply copy what ever you want to one of the<br />
preffered PATH directory which you can see<br />
after running env command. Since I add<br />
~/bin to my PATH with .xsession.<br />
I simply take all by doing:  </p>
<blockquote>
<p><code>cp bin/* ~/bin</code>  </p>
</blockquote>
<h3>4) clean up</h3>
<p>This simply removes stuff make created<br />
inside the directory of your makefile.  </p>
<blockquote>
<p>'make clear'</p>
</blockquote>
<h2>Program list:</h2>
<ol>
<li>
<p><strong>coin</strong>  </p>
<blockquote></blockquote>
<p>Program lets you find an answer to a 0/1 problem.<br />
Program does not take any arguments.<br />
Dependencies: none
Example of using it:  </p>
<blockquote>
<p><code>coin</code> </p>
</blockquote>
</li>
<li>
<p><strong>getproxies</strong> <code>[ pattern ]</code>  </p>
<blockquote></blockquote>
<p>Program filters few webpages to suck up proxies,<br />
also checks  if they work properly. Data is saved<br />
to a file named  "proxylist" inside working directory.<br />
Slow proxies that do not respond quick enought and<br />
resoults that repeated are removed.<br />
The file will contain each uploaded proxy data per line.<br />
Lines will be formated like this:  </p>
<blockquote>
<p><code>&lt;IP&gt; &lt;port&gt; &lt;country&gt; &lt;anonimyty type&gt; &lt;http or https support&gt;</code></p>
</blockquote>
<p>Program takes arguments. If line contains any<br />
of the passed words, the line will be removed.<br />
The search is case insensetive. So passing<br />
'http' or 'HTTP' will remove any line that contains 'http'<br />
Dependencies: <strong>wget</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>getproxies china</code>  </p>
</blockquote>
<p>This will create the 'proxylist' file with resoults but<br />
without lines containing word 'china'. Upper or<br />
lower cases won't matter. So line contaning 'chINA'<br />
will also be removed. China proxies most times are garbage,<br />
so you want them removed. Other type of use would be<br />
getting rid 'transparet' proxies.  Altho you should never<br />
trust anonimity type of proxy. Some servers will pass<br />
your IP if for example user-ganet will not fit their<br />
expectations.  </p>
</li>
<li>
<p><strong>novena</strong></p>
<blockquote></blockquote>
<p>Program will save file in home directory and track what<br />
current day of novena we have. Program does not take any<br />
arguments. It will either tell you the current novena<br />
day (novena lasts 9 days always). Or it will ask you<br />
for new novena name. Program creates in user home<br />
directory taken from enviroment list .novena file. Where<br />
it keeps data. If 9 days pass program will inform you<br />
the novena has ended.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>novena</code>  </p>
</blockquote>
</li>
<li>
<p><strong>workout</strong></p>
<blockquote></blockquote>
<p>Program generates workout entries for each day. Entries<br />
are stored inside .workout file in enviroment home<br />
directory. Program does not take any arguments.<br />
The file is generated automatically when program is run.<br />
For current day it shall output:  </p>
<ul>
<li>exercise type,  </li>
<li>weight level - how much load you will lift   </li>
<li>series count per exercise  </li>
<li>Hardness - how many times repeate per one series  </li>
<li>Count of exercise type  </li>
</ul>
<p>Dependencies: none<br />
Example of using it::  </p>
<blockquote>
<p><code>workout</code>  </p>
</blockquote>
</li>
<li>
<p><strong>logtime</strong></p>
<blockquote></blockquote>
<p>Program logs time per each line  that appears at stdin.<br />
Output format:  </p>
<blockquote>
<p><code>&lt;seconds&gt;.&lt;miliseconds&gt;&lt;space&gt;&lt;passed line&gt;</code>  </p>
</blockquote>
<p>Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>program | logtime</code>  </p>
</blockquote>
<p>You should rememer that | is buffered and will not<br />
pass everything immediatly always. So the real time<br />
will can be different than the loged one.  </p>
</li>
<li>
<p><strong>recev</strong></p>
<blockquote></blockquote>
<p>Program creates a record of pressed mouse buttons,<br />
keyboard keys and mouse moves. Program at start<br />
will ask you are you ready. After that you will<br />
need to decide what key will start and stop recording.<br />
You can chose only single keys. Combinations do not<br />
work. You need to type the key so for example<br />
it could be 'F8' or h. After the key is picked,<br />
you must provide a filenmae, where the event data<br />
gets recorded. File will be placed in working<br />
directory. Events that do not matter and repeated<br />
mousemoves are removed to shrint at least a bit the<br />
file where events get saved.  Since it can grow quite<br />
big. This program does not take any arguments.<br />
Aditionaly <strong>xenv</strong> program can help with finding key name.<br />
Dependencies:  <strong>xmodmap</strong>, <strong>xinput</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>recev</code></p>
</blockquote>
</li>
<li>
<p><strong>playev</strong> <code>[ file name ] [ number ] [ seconds ] [ seconds ]</code></p>
<blockquote></blockquote>
<p>Program playes events from file created by recev program.<br />
Program needs four arguments:  </p>
<ul>
<li>file name - it is the file created by recev.  </li>
<li>number of times event gets repeated, 0 causes<br />
to be repeated infinite times.  </li>
<li>seconds to wait before playing events loop  </li>
<li>seconds to wait between instance of recorded events.  </li>
</ul>
<p>Dependencies: <strong>xmodmap</strong><br />
Example of using it:  </p>
<blockquote>
<p><code>playev recorded_file 100 10 1</code></p>
</blockquote>
<p>This will play event recorded in passed file name<br />
100 times. Program will start playing events after<br />
10 seconds and each time all events in recorded<br />
file are played, it will wait 1 second and replay the<br />
events. Untill reached the expected repeated number.  </p>
</li>
<li>
<p><strong>gethostipv</strong> <code>[ -46 ] [ domain ]</code></p>
<blockquote></blockquote>
<p>Program uses system resolver tools to get the ip<br />
of the domain. Program expects at least the domain name<br />
argument. Order of arguments does not matter. But at<br />
maximum there can be only two arguments. So the options<br />
must not be separated like this: <code>-4 -6</code><br />
Instead it should look like this: <code>-46</code><br />
So we have four possibilities of passing options:  </p>
<blockquote>
<p><code>-4 or -6 or -46 or -64</code>  </p>
</blockquote>
<p>Options:  </p>
<p><code>-4</code><br />
Look only for IPv4 address  </p>
<p><code>-6</code><br />
Look only for  IPv6 address  </p>
<p>Address shall only be outputted to stdout if it is possible<br />
to connect to it. Mapping ipv4 to ipv6 is not checked.<br />
So if the host has ipv6 and ipv4  but we can't connect to ipv6<br />
and instead we need to use ipv4. When flag <code>-46</code> was passed,<br />
ipv4 will be shown.  But if we passed option<code>-6</code>.<br />
Nothing shall be outputted. If host has more addresses,<br />
and we can connect to each of them.<br />
All will be outputted. Passsing <code>-46</code> means - check first for<br />
ipv4, than for ipv6. If <code>-64</code> vice versa.<br />
If we pass domain name without options. Both ipv4 and ipv6<br />
are checked, but the order is undefined.
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>gethostipv -64 www.dom.com</code>  </p>
</blockquote>
<p>In which we ask to output first ipv6 possible addresses<br />
that we could connect to and than ipv4. For the<br />
www.dom.com domain.  </p>
</li>
<li>
<p><strong>repeatstr</strong> <code>[ number ] [ pattern ]</code></p>
<blockquote></blockquote>
<p>Program repeats passed phrase specified number of times.<br />
There are always expected two arguments.<br />
First one is number of times string will be repeated.<br />
Second is the string it self that program will repeat.<br />
Supported character sequances:  </p>
<ul>
<li><code>\a</code> = bell  </li>
<li><code>\b</code> = backspace  </li>
<li><code>\f</code> = form feed  </li>
<li><code>\n</code> = new line  </li>
<li><code>\r</code> = carrige return  </li>
<li><code>\t</code> = tab  </li>
<li><code>\v</code> = vertical tab  </li>
<li><code>\\</code> = backslash  </li>
</ul>
<p>Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>repeatstr 100 'this gets repeated 100 times'</code></p>
</blockquote>
</li>
<li>
<p><strong>lext</strong> <code>[ -clp ] [ pattern1 ] [ pattern2 ]</code>  </p>
<blockquote></blockquote>
<p>Program extracts strings form stdin. Don't pass any<br />
arguments to it and help will be outputed.<br />
For proper use, this program expects arguments.<br />
There are three options to chose from. 
Options:  </p>
<p><code>-c _string1_ _string2_</code><br />
Output data between <em>string1</em> and <em>string2</em><br />
Which both are on same line.  </p>
<p><code>-l</code><br />
Loop last command.  </p>
<p><code>-p _string_</code><br />
Pass data untill <em>string</em> is located.  </p>
<p>After EOF is met - program ends.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>cat datafile | strext -p 'dev' -c 'name="' '"' -l</code>  </p>
</blockquote>
<p>This will read datafile from stdin untill 'dev' is met.<br />
After that program will look for data which lies between<br />
'name="' and '"' where both strings will be on the same line.<br />
Finally loop the last command, look for dara between<br />
specified strings untill EOF met on stdin.</p>
</li>
<li>
<p><strong>getlimits</strong></p>
<blockquote></blockquote>
<p>Program prints system soft and hard resource consumption.<br />
Basic are:  </p>
<ul>
<li>Maximum core file size  </li>
<li>Maximum CPU time used by each process  </li>
<li>Maximum size of data segment including allocations  </li>
<li>Maximum size of file that can be created  </li>
<li>Maximum number of file descriptors process can open  </li>
<li>Maximum size of process stack  </li>
<li>data segment etc.  </li>
</ul>
<p>Few other system dependant also are printed for linux and<br />
OpenBSD.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>getlimits</code>  </p>
</blockquote>
</li>
<li>
<p><strong>fstrswp</strong> <code>[ pattern1 ] [ pattern2 ]</code></p>
<blockquote></blockquote>
<p>Program will read line and swap any found  string from first argument,<br />
to string in second argument. I use it for source fixing.<br />
Each line gets allocated to heap. After swapping is done<br />
output is sent to stdout anf line gets freed.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>find src -type f -iname '*.c' -exec sh -c \</code><br />
<code>'cat {} | fstrswp '\''malloc.h'\'' '\''stdlib.h'\'\</code><br />
<code>' | tmpfile; mv tmpfile {}' \;</code>  </p>
</blockquote>
<p>This fixes gnuism crap left in code by some<br />
unexpiranced coder. Next run would scan <code>*.h</code>.  </p>
</li>
<li>
<p><strong>parsekdump</strong></p>
<blockquote></blockquote>
<p>This program is openbsd ktrace/kdump output parser.<br />
It shall count system calls and create a summary<br />
of them. It outputs data per PID/TID and on start<br />
summary of all treads and forks.<br />
Summary will contain:</p>
<ul>
<li>System call name</li>
<li>Count of times it was called in all forks and threads</li>
</ul>
<p>Each basic data line for PID/TID will contain:  </p>
<ul>
<li>System call name</li>
<li>Count of times it was called in the process</li>
<li>Procent of system call summary compared to all system calls time</li>
<li>Procent of system call summary to record time</li>
</ul>
<p>Dependencies: openbsd operating system<br />
Example of using it:</p>
<blockquote>
<p><code>ktrace -i program</code><br />
<code>parsekdump</code>  </p>
</blockquote>
<p>ktrace -i option is for tracking forks and threads. I advice to track all<br />
else the output summary might be missleading.  </p>
</li>
<li>
<p><strong>ualist</strong></p>
<blockquote></blockquote>
<p>PROGRAM REMOVED, it makes more sens to provide a list of useragents from<br />
a server. Which I will soon do.</p>
</li>
<li>
<p><strong>randstr</strong> <code>[ -uld ] [ number ]</code></p>
<blockquote></blockquote>
<p>Program generates random string. It uses pseudorandom generator,<br />
Deterministic C rand().<br />
Without any options any bytes can appear.  So it can even generate nul.<br />
To force more usefull output we have options which we can mix:  </p>
<p><code>-u</code><br />
Print out only upper case output.  </p>
<p><code>-l</code><br />
Print out only lower case output.  </p>
<p><code>-d</code><br />
Print out only digits  </p>
<p>There is no expected order of arguments.<br />
Dependencies: none<br />
Example of using it:  </p>
<blockquote>
<p><code>randstr -uld 50</code>  </p>
</blockquote>
<p>In this example we generate 50 characers where each of them<br />
must be a digit or an upper/lower case alphabet number.<br />
Second example above does the same thing, as we can see,<br />
options can be together and can repeate.  </p>
<blockquote>
<p><code>randstr -d 50 -uuuud -udl</code>  </p>
</blockquote>
</li>
<li>
<p><strong>logdata</strong>  <code>[ unix socket name ]</code></p>
<blockquote></blockquote>
<p>Program opens unix socket with name passed in argument.<br />
All data send to the socket will be redirected to stdout.<br />
Gentle way of exiting the program is sending SIGINT signal to it.<br />
dependencies: none<br />
Example of using it:</p>
<blockquote>
<p><code>logdata /tmp/sunXXX &gt; save_loged_data_here</code></p>
</blockquote>
<p>This will create unix socket file /tmp/sunXXX and save<br />
all coming data to save_loged_data_here.<br />
An example of sending test data would look like this:</p>
<blockquote>
<p><code>echo "test" | nc -UN /tmp/sunXXX</code></p>
</blockquote>
</li>
<li>
<p><strong>runprog</strong> - Program opens unix socket and runs program
              or script we pass at it start up. It runs the command when
              there is opened connection. It ignores sent data.  You can either
              not even wait for the program to finish running the command
              or wait.
              I decided that there is no sens for inet socket type feature.
              Unix socket is better fit for IPC without outside interferation.
              Example: ./runprog '/tmp/sun' './runthisscript';
              Than ask it to run it but don't wait for it to finish: nc -Uz '/tmp/sun'
              Or ask it to run it and wait till it finish: nc -Ud '/tmp/sun'
              Runprog closes gently when recives sigint. Additional one more argument
              is for groups. You can do:
              ./runprog '/tmp/sun' './runthisscript' 'go'
              last one go stand for group and other - write permissions set on
              unix socket. So if you need root to execute something simple user
              can call it via this socket to do the job.</p>
</li>
<li>
<p><strong>httpreq_addcrlf</strong> - Program adds after new line of each entry CRLF creating
              proper http request. On the end it makes passes one more CRLF.
              Empty lines are being ignored. Example of usage, we have file httpreq:</p>
<pre><code>      GET /babylon/tower HTTP/1.0
      Host: gagle.shit

      We use it this way:
      cat httpreq | httpreq_addcrlf | netcat gagle.shit 80
</code></pre>
</li>
<li>
<p><strong>flinemem</strong> - program loads stdin line to memory and searches if passed arguments
          exist in line. Line is printed to stdout only if all strings exist in line.
              No need for regular expression when you simply need to find static patterns.
              Example fo using:  cat file | flinemem 'pattern1' 'pattern2' 'pattern3' </p>
</li>
<li>
<p><strong>urlcode</strong> - at the moment we have 3 options, encode (-e), decode (-d)  and
              'make post body' (-p). How to use:
              echo 'string to @#$ encode" | urlcode -e | urlcode -d
              This will encode irl string and than decode it. Now the post part is a bit tricky.
              First argument after options gets encoded and second argument does not.
              Than third gets encoded and fourth does not. And so on.
              We would use it in script like this:</p>
<pre><code>      postbody=$( encode -p 'login' '=' 'someone' '&amp;' \
                            'pass' '=' '7ygft67$%^&amp;*some' '&amp;' \
                            'hidden_token' '=' '12fjwhr@#$Rwef345r3tGF#$$' )
      # at this moment we find out the lengh of body and pass it for contetn lengh 
      # after forming the http header we simply send this stuff like this using 
      # former tools from this soft pack ( httpreq_addcrlf ):
      { cat httpreq | httpreq_addcrlf | cat; printf "%s" "$postbody"; } | \
      nc -c -X 5 -x localhost:9050 www 443

      # Hope this is clear. The last line shows nc with passing traffic via tor
      # for server with https.
</code></pre>
</li>
<li>
<p><strong>givetask</strong> - Simple program, opens unix socket from first argument. And outputs each line
               from stdin per connection. Then shutdowns and closes each socket. Example:
               cat file | givetask /tmp/some; nc -U /tmp/some </p>
</li>
<li>
<p><strong>miodpitny</strong> - program tells you MEAD proportions. </p>
</li>
<li>
<p><strong>irclog</strong> - program to log irc. It's old code. Not too proud of it but I needed to log
             some stuff recently and it worked. So I am adding it here for now.
             Will try to reread it in future for detecting some bugs and other crap.
             How to use: create a file in directory where you will start the irclog program
             The only accepted file name is: log_serv_data
             Else error.
             Contents example:
             Sirc.liberapriviligesqwertycrap.chat 6667
             MNICK dicky 
             MUSER dicky ** :Philip_DICK
             C##channel_1
             C#devchannel_2
             C##channel_3</p>
<pre><code>     Now, S is for server where you pass domain port
     M is for first message you provide at start up, irc proto
     C is for channel you want to join
     There is also I for identication string. I rememebr ages ago it worked but now?
     This will have sooner or later update. But since it works than I am putting it up here.
     Expect broken behavior. It was intended to be able log multiply servers. So next S in 
     config file should merit new network.
     Each channel gets it's own file where stuff gets logged in the directory where you 
     started the program. &lt;networkname&gt;&lt;channame&gt; &lt;- something like this
</code></pre>
<ol>
<li><strong>faddlines</strong> - Program merges files. pritnf on stdout added lines like this:
         line 1 file 1 + space + line 1 file 2\n
         If one file reached eof it gets ignored
         after all files reach EOF - program finishes.
         Where I use it:<pre><code> Let us imagine we have y(t) and x(t);
 We want to plot it in gnuplot;
 We could also have already data files out there.
 Taken from some sensor.

 echo 'for(i=0.1; i &lt; 100; i+=0.1) { i-5 }' | bc &gt; file1
 echo 'for(i=0.1; i &lt; 100; i+=0.1) { i+5 }' | bc &gt; file2
 faddlines file1 file2 &gt; ans;
 ## After that I can plot x,y points with gnuplot to see how it looks.
 gnuplot
 &gt;&gt; p ans

 This program can take multiply files.
</code></pre>
</li>
</ol>
</li>
<li>
<p><strong>cutfile</strong> - program stdouts lines after meeting in line some expression.
              For help run cutfile without any arguments</p>
</li>
<li>
<p><strong>htmlentities</strong> - decode or encode html entities, only some are supported.
                   suported: '&lt;' '&gt;' ' ' '\'' '"' '&amp;' . Rets is treated as errror.
                   honestly I dislike utf8. Let it rot. 
                   How to use -&gt; invoke without any arguments. Still little example:
                   cat urllinksfromhtmlpage | htmlentities -d &gt; proper_url_links</p>
</li>
<li>
<p><strong>httphb_split</strong> - Splits http server answers to http header or the rest ( body )
                   For help simply run it without any arguments.
                   Example: http_serber_answer | httphb_split -h &gt; httpheader_file</p>
</li>
<li><strong>fixedxarg</strong> - Program closly performs same task as xargs, BUT PROPERLY.
                Each new line separates new argument. Empty lines creates ''
                Which normal xarg fails to catch. No options. Example:
                echo  "a\nb\nc\nd\n" | fixedxarg echo</li>
<li><strong>listwords</strong> - </li>
</ol>